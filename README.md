Бражкин Ярослав 311гр.

Многопоточность дает возможность выполнения нескольких частей программы параллельно, что может повысить производительность. 

Главная идея пулов потоков, что потоки не нужно каждый раз создавать с нуля и потом убивать, т.к потребляет много ресурсов (особенно если приложение создает потоки, которые живут недолго). Для этого есть пулы потоков, которые решают эту проблему. Они дают нам готовый набор потоков, которые сидят, ждут задачи. Пришла задача — один из них берёт, делает, а после возвращается обратно, готовый к новой работе (не уничтожается!).

ExecutorService - интерфейс, который позволяет просто передавать ему задачи, а он сам разбирается, какой поток взять из пула и как всё разрешить. Т.е. отделяет процесс создания\управления потоками от логики выполнения задач. Интерфейс находится в java.util.concirrent. 
Если задача что-то возвращает (например, результат вычислений), то есть Future<T> – что-то вроде обещания, что результат будет, но потом. Он позволяет получить результат выполнения задачи, отменить по необходиости, проверить статус. А если просто надо что-то выполнить, без ответа, то следует использовать execute. Когда закончил, надо не забыть вызвать shutdown(), чтобы он все потоки завершил.

Основные методы ExecutorService:
1. execute(Runnable command): Выполняет задачу Runnable в одном из потоков пула. Не возвращает никакого значения и не позволяет проверить статус выполнения.
2. submit(Callable<T> task): Выполняет задачу Callable (которая может возвращать результат и выбрасывать исключения) и возвращает Future<T>..
3. shutdown(): Инициирует завершение работы, при котором ранее отправленные задачи выполняются, но новые задачи не принимаются.
4. shutdownNow(): Пытается остановить все активно выполняющиеся задачи, останавливает обработку ожидающих задач и возвращает список задач, которые не были запущены.

Executors. Это фабрика, которая сама создает разные виды ExecutorService. Например, newFixedThreadPool(3) – это если необходимо ровно три потока, и не больше. Все остальные задачи будут ждать в очереди. Или newCachedThreadPool() – сам решает, сколько потоков надо, если задач много, он новых создаёт, а если потоки простаивают, то их убирает. Это очень удобно, чтобы самому не заморачиваться с пулами.
Примеры методов Executors:
1. newFixedThreadPool(int nThreads): Создает пул потоков с фиксированным количеством потоков. Если все потоки заняты, новые задачи будут ждать в очереди.
2. newCachedThreadPool(): Создает пул потоков, который создает новые потоки по мере необходимости, но повторно использует ранее созданные потоки, когда они доступны. Потоки, которые не использовались в течение определенного времени, завершаются.
3. newSingleThreadExecutor(): Создает ExecutorService с одним потоком. Задачи будут выполняться последовательно. Гарантирует, что все задачи выполняются в одном и том же потоке. Полезно для сохранения порядка выполнения.
4. newScheduledThreadPool(int corePoolSize): Создает пул потоков, который может планировать выполнение команд с задержкой или периодически.

(код с прошлой сессии)

```java
public class Example {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3);

        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            executor.execute(() -> {
                System.out.println("Выполняется задача " + taskId + " в потоке: " + Thread.currentThread().getName());
                try {
        // Имитация работы
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }

        Future<Integer> futureResult = executor.submit(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                System.out.println("Выполняется сложная задача в потоке: " + Thread.currentThread().getName());
                Thread.sleep(2000);
                return 123;
            }
        });

        try {
            System.out.println("Результат: " + futureResult.get()); // Блокирует до получения результата
        } catch (Exception e) {
            e.printStackTrace();
        }

        executor.shutdown();
        System.out.println("ExecutorService завершает работу.");
    }
}
```

Аутентификация и авторизация (раньше путал наверное каждый). Аутентификация – это когда система выясняет, кто ты есть. Ты вводишь логин-пароль, и она проверяет, ты ли это. А вот авторизация – это уже когда система понимает, что тебе можно делать, после того, как ты доказал, кто ты. Например, в Мой МТС я сначала логинюсь (аутентификация), а потом уже могу переводы делать или выписки смотреть (авторизация).

Тут переходим на тему JWT токенов. Этоэто компактный, URL-безопасный способ представления информации о заявках, которая должна быть передана между сторонами. Он состоит из трёх частей: заголовок, сама информация (payload) и подпись. Информация в JWT представлена в виде объекта JSON. JWT широко используются для обмена информацией (например, аутентификационных данных) между клиентом и сервером. JWT состоит из трех частей, разделенных точками. Подпись очень важна – она гарантирует, что никто этот билетик не подделал и не изменил.
Как это работает? Ты логинишься, сервер проверяет, что ты это ты, и выдаёт тебе JWT Token. Ты его хранишь у себя в браузере. Потом, когда ты делаешь запросы к защищенным ресурсам, ты просто отправляешь этот токен вместе с запросом. Сервер его получает, проверяет подпись (это быстро, поскольку не надо делать запрос в базу данных) и смотрит, что в полезной нагрузке. Если всё хорошо, то пропускает тебя. Главный плюс – stateless, то есть серверу не надо помнить про твою сессию, он просто по токену всё понимает. А когда хочешь выйти, просто удаляешь токен из браузера, и всё.

Есть и другой подход – сессионные токены, которые хранятся в Redis. Тут немного по-другому. После логина сервер тоже генерирует токен, но он сам по себе ничего не значит, это просто случайная строка. А вот всю информацию про твою сессию (кто ты, какие у тебя права) сервер хранит у себя в Redis. Твой токен, который тебе пришёл, просто служит ключом к этой информации в Redis.

Когда ты делаешь запрос, твой браузер отправляет этот сессионный токен (обычно в cookies), сервер берёт его, ищет в Redis и находит твою сессию. Если она там есть и не истекло время, то пропускает тебя. Чтобы выйти, сервер просто удаляет твою сессию из Redis, и всё, твой токен становится недействительным.

Если сравнивать JWT и сессионные токены в Redis, то у каждого свои плюсы и минусы. JWT хорош, потому что он stateless – серверы не зависят друг от друга, легко масштабировать, и он отлично подходит для микросервисов, потому что каждый сервис может сам проверить токен. Но его сложно отозвать, если он вдруг скомпрометирован до истечения срока. Также требует генерации нового токена, если данные пользователя изменились.
Сессионные токены в Redis, наоборот, очень легко отозвать – просто удалил запись из Redis, и всё. И они безопаснее от XSS, если использовать HTTP-only куки. Но зато это stateful – серверу надо хранить состояние каждой сессии, постоянно дёргать Redis. Это добавляет зависимость и, в очень больших масштабах, может чуть усложнить горизонтальное масштабирование. Как итог, нужно выбирать, что лучше подходит под конкретный проект.

